# import:
#   - https://www.nextzen.org/carto/refill-style/11/refill-style.zip
#   - https://www.nextzen.org/carto/refill-style/themes/color-zinc.zip
textures:
    data_image:
        url: real_total_data.png
        filtering: nearest
sources:
    nextzen_vector_tile:
      type: MVT
      url: https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=hx2J5tx6QDS1Pnhu8r97JQ
    dong:
        type: GeoJSON
        url: ./real_final_total_population_int.geojson

styles:
    dongStyle:
        base: polygons
        animated: true
        material:
            ambient: 1.0
            diffuse: 1.0
        shaders:
            defines:
                TWO_PI: 6.283185307
                PI: 3.1415926535897932384626433832795
                HALF_PI: 1.5707963267948966192313216916398
            uniforms:
                u_data: data_image
                u_param: [528, 424]
                u_offset: 0.
            blocks:
                global: |
                      float getIndex (vec2 encodedIndex) {
                        return (encodedIndex.x*65025.+encodedIndex.y*255.)+.5;
                      }

                      float shape(vec2 st, int N){
                          st = st *2.-1.;
                          float a = atan(st.x,st.y)+PI;
                          float r = TWO_PI/float(N);
                          return cos(floor(.5+a/r)*r-a)*length(st);
                      }
                      vec4 getColor (vec2 st) {
                          float texWidth = u_param.x;
                          float texHeigth = u_param.y;
                          st.y = 1.-(st.y/texHeigth);
                          return texture2D(u_data,vec2(st.x/texWidth,st.y));
                      }
                color: |
                  float yIndex = getIndex(color.xy);
                  vec4 colorData = getColor(vec2(mod(u_offset,u_param.x), mod(yIndex, u_param.y) ));
                  float cData = (colorData.r+colorData.g+colorData.b)/3.0;
                  color.rgb = vec3(cData, (0.5 - cData/2.), 7.0);
                position: |
                    float zz = (position.z + .5);
                    vec4 sampleData = getColor(vec2(mod(u_offset, u_param.x) , mod(zz, u_param.y)));
                    position.z = ceil(position.z /500.);
                    position.z *= (sampleData.r + sampleData.g  + sampleData.b)*3000.;


global:
    currentTime: 2018041800

cameras:
    camera1:
        type: isometric

layers:
    earth:
      data: { source: nextzen_vector_tile }
      draw:
          polygons:
              color: "#ddd"
              order: 0
    water:
      data: { source: nextzen_vector_tile }
      draw:
          polygons:
              color: "#6666ff"
              order: 1
    roads:
      data: { source: nextzen_vector_tile }
      draw:
          lines:
              order: 4
              color: '#ffffff'
              width: [[7,0.0px], [10, .5px], [15, .75px], [17, 5m]]
    dong:
        data: { source: dong }
        draw:
            dongStyle:
                interactive: true
                order: 3000
                color: |
                  function () {
                    return [ ( Math.floor(feature.id/255))/255, (feature.id%255)/255, 0 ]
                  }
                extrude: |
                  function () {
                    return feature.id;
                  }
            text:
                text_source: id
                offset: [0, 20]
                font:
                    fill: black
                    size: 12px
